;; -*- mode: lisp -*-

The Order of Symbols
--------------------

The following is meant to be both an introduction and reference to
Sigil, the Lisp that is used by Eturia.  You will find an explanation
of syntax, followed by the list of builtins, followed by a brief
explanation of the editor and then there is a set of examples that can
be followed along and typed into the Eturia Listener, which can be
found at:

    http://busfactor1.ca/bin/eturia

To run Eturia, click 'Engage'.

This paper is meant to follow the ideas of Guy Steele in his
talk/paper 'Growing a language':

    https://www.cs.virginia.edu/~evans/cs655/readings/steele.pdf
    https://www.youtube.com/watch?v=_ahvzDzKdB0

All terms in the following text are (hopefully) defined before use.

Syntax
======

The following is the syntax of Sigil:

Symbol - a string of characters not containing '(', or ')'.
-----------------------------------------------------------

Example:

    x is a symbol
    abc is a symbol
    x123 is a symbol
    123x is a symbol
    a-longer-symbol is a symbol
    |a symbol with spaces| is a symbol


Numbers - a string of digits
----------------------------

Example:

    1 is a number
    100 is a number
    3.141516 is a number


Comments - a string of characters up to a newline that is ignored
------------------------------------------------------------------

Example:

    ; this is a comment


List - build lists
------------------

Example:

    (1 2 3) ; is a 'proper' list of the digits 1 2 3
    (1 . 2) ; is an 'improper' list of the digits 1 and 2

A proper list has () as its last element.
An improper list does not.

Quoting - stops evaluation
--------------------------

Example: `(1 2 3) => (1 2 3)


Comma - evaulate inside of a quote
----------------------------------

Example:

    (set `x 1) => 1
    `(x 2 3) => (x 2 3)
    `(,x 2 3) => (1 2 3)


Comma at - evaluate a list inside of a quote, and splice it
-----------------------------------------------------------

Example:

    (set `x `(a b c))
    `(x 2 3) => (x 2 3)
    `(,x 2 3) => ((a b c) 2 3)
    `(,@x 2 3) => (a b c 2 3)


NOTE: SYMBOLS AND NUMBERS ARE ALSO KNOWN AS ATOMS.


Booleans - () is false, everything else is true

Builtins
========

The following are the builtin commands for Sigil:

1) atom - a predicate to test if its argument is an atom (string, number, or ())
---------------------------------------------------------------------------------

Example:

    (atom t) => t
    (atom ()) => t
    (atom `x) => t
    (atom `(1 2 3)) => ()

2) eq - a predicate to test if 2 atoms are equal
------------------------------------------------
Example:

    (eq t t) => t
    (eq () ()) => t
    (eq t ()) => ()
    (eq `x `x) => t
    (eq `x `y) => ()
    (eq 1 1) => t
    (eq 1 2) => ()
    (eq `(1 2 3) `(1 2 3)) => () ; notice!

3) cons - create a new list cell
--------------------------------

Example:

    (cons 1 ()) => (1)
    (cons `x ()) => (x)
    (cons 1 2) => (1 . 2) ; notice!
    (cons (1 (cons 2 ()))) => (1 2)

4) car - return the first element of a list
-------------------------------------------

Example:

    (car `(1 2 3)) => 1
    (car `((1 2 3) 2 3)) => (1 2 3)
    (car ()) => ()
    (car `x) => ; Error
    (car 1) => ; Error

5) cdr - return everything but the first element of a list
----------------------------------------------------------

Example:

    (cdr `(1 2 3)) => (2 3)
    (cdr `((1 2 3) 2 3)) => (2 3)
    (cdr ()) => ()
    (cdr `x) => ; Error
    (cdr 1) => ; Error

6) cond - conditional statement, execute tests until one returns not (),
          and then execute the following statement
------------------------------------------------------------------------

Example:

    (cond (t 1)) => 1
    (cond (() 1)) => ()
    (cond ((t 1) (t 2))) => 1
    (cond ((() 1) (t 2))) => 2
    (cond ((() 1) (() 2) (t 3))) => 3
    (cond ((() 1) (t 2) (t 3))) => 2
    (set `x ())
    (set `y t)
    (cond
      (x `shouldnt-get-here)
      (y `should-get-here)
      (t `wont-get-here)) => should-get-here

7) qquote - prevent evaluation of the argument, allowing for unquote
            and unquote splicing, normally abbreviated with `
--------------------------------------------------------------------

Example:

`(1 2 3) => (1 2 3)
(set `x 1) => 1
`(,x 2 3) => (1 2 3) ; unquote with ,
`(,@x 2 3) => (1 2 3) ; Error
(set `x `(1 2 3)) => (1 2 3)
`(,x 2 3) => ((1 2 3) 2 3) ; unquote with ,
`(,@x 2 3) => (1 2 3 2 3) ; unquote splice a list with ,@

8) set - assign a symbol a value (variables)
--------------------------------------------

Example:

(set `x 1) => 1
x => 1
(set `x 2) => 2
x => 2
(set `x `(1 2 3)) => (1 2 3)
x => (1 2 3)
(set `x 1 `y 2 `z 3) => 3

9) lambda - create an anonymous function
----------------------------------------
Example:

(lambda (x) x) => (lambda (x) x)
((lambda (x) x) 1) => 1 ; call the function immediately
((lambda (x) (+ x x)) 2) => 4
(set `double (lambda (x) (+ x x))) ; declare function
(double 2) => 4 ; call declared function

10) self - the current function that is executing, used for recursion
---------------------------------------------------------------------

Example:

((lambda (l)
   (cond
     ((cdr l) (car l))
     (t (self (cdr l))))) `(1 2 3)) => (3) ; return the last element
                                           ; of the list, recursively

11) apply - call a function with a list of arguments
----------------------------------------------------

Example:

(apply (lambda (x) (+ x x)) `(1)) => 2
(apply (lambda (x y z) (+ x y z)) `(1 2 3)) => 6
(apply double 2) => 4 ; using previously defined function in 9)

12) values - return multiple values from a function
---------------------------------------------------

Example:

(values 1) => 1
(values 1 2) => 1
2
((lambda (x) (values x)) 1) => 1
((lambda (x y) (values x y)) 1 2) => 1
2

13) bind - bind multiple values to symbols
------------------------------------------

Example:

(set `multiple-values (lambda (x y) (values x y))) => ...
(bind (a b) (multiple-values 1 2) (cons a b)) => (1 . 2)

14) defmacro - define a macro
-----------------------------

Just watch the show:

    https://www.livecoding.tv/burtonsamograd/videos

WRITEME

15) + - addition, sum
---------------------

Example:

    (+ 1 2) => 3
    (+ 1 2 3) => 6

16) - - subtraction, difference
-------------------------------

    (- 1 2) => -1
    (- 1 2 3) => -4

17) * - multipley, product
--------------------------

    (* 1 2) => 2
    (* 1 2 3) => 6

18) / - divide, quotient
------------------------

Example: 

    (/ 1 2) => .5
    (/ 1 2 3) => 0.1666....

19) % - remainder, mod
----------------------

Example:

    (% 5 2) => 1

19) rm - remove a symbol from the environment

Example:

    (set `x 1) => 1 ; define a symbol in the environment
    x => 1
    (rm `x) => 1 ; returns the old value of x
    x => ; Error, undefined symbol

19) rmf - remove a macro from the function environment

Example:

    (defmacro double (x) `(+ x x)) => (macro (x) `(+ ,x ,x))
    (double 2) => 4
    (rmf `double) => (macro (x) `(+ ,x ,x))
    (rm `double) => (lambda (x) (+ x x))
    (double 2) => ; Error, undefined function

20) env - return the current environment

Example:

     (env) => ((t . t) ...)

21) fenv - return the current function environment

Example:

    (fenv) => ((set . builtin) (cons . builting) ...)

22) save - save the current environment and function environment to
           local storage using argument as the name of the core
--------------------------------------------------------------------

(save) => ; default /core is saved
(save /backup) => ; saved to /backup in local storage

23) load - load a core into the current environment

THIS FEATURE IS CURRENTLY NOT IMPLMENTED.

Editor
------

Like VI, but different:

hjkl - move the cursor left, down, up, or right (h,j,k,l)
i - insert mode, allows you to type overwrite text in the buffer
? - command mode, allows you to execute the following commands
e - evaluate lisp code
z - clear the screen
np - previous/next in history (experimental)

To type characters use 'insert' (overwrite) mode by pressing 'i'.

REMEMBER TO CLICK IN THE WINDOW TITLE BEFORE TRYING TO TYPE IN THE
LISTENER.

Window Manager
--------------

- click in title bar to focus window
- middle click in title bar to remove window

Exercises
---------

The following exercies build upon the primitives defined above and are
meant to be typed into the Eturia 'Listener' console.

1) if - tradional conditional
-----------------------------

Example: (if (eq t t) 1 2) => 1
Example: (if (eq t ()) 1 2) => 2

(defmacro if (test true false)
  (cond
    (,test ,true)
    (t ,false)))
    
2) when - single branch conditional
-----------------------------------

Example: (when (eq t t) 1) => 1
Example: (when (eq t ()) 1) => ()

(defmacro when (test &body body)
  (cond
    (,test ,@body)))

3) unless - negative single branch conditional
----------------------------------------------

Example: (unless (eq t t) 1) => ()
Example: (unless (eq t ()) 1) => 1

(defmacro unless (test &body body)
  (cond ,test ,@body))

4) reverse - reverse a list
---------------------------

(defmacro reverse (l)
  `((lambda (l a)
      (if l
          (self (cdr l) (cons (car l) a))
          a))))

5) map - build a list by running the function f ovar the entries in
         list l
-------------------------------------------------------------------

(defmacro map (f l)
  `((lambda (l a)
      (if l
          (self (cdr l) (cons (,f (car l))))
          (reverse a))) ,l ()))

5.5) caar, cadr, cdar and cddr - shortcuts
------------------------------------------

(defmacro caar (x)
  `(car (car ,x)))

(defmacro cadr (x)
  `(car (cdr ,x)))

(defmacro cdar (x)
  `(cdr (car ,x)))

(defmacro cddr (x)
  `(cdr (cdr ,x)))

6) let - declare local variables
--------------------------------

(defmacro let (args &body body)
  (lambda (vars values)
    `((lambda ,vars ,@body) ,@args)
    (map car args)
    (map cadr args))) ; this should work, if not, try the below version

(defmacro let (args &body body)
  (lambda (vars values)
    `((lambda ,vars ,@body) ,@args)
    (map car args)
    (map (lambda (x) (car (cdr x)) args))))

Examples:

    (let ((x 1) (y 2)) (+ x y)) => 3

7) aif - anamorphic if
----------------------

(defmacro aif (test true false)
  `(let ((it ,test))
     (if it ,true ,false)))

8) awhen - anamorphic when
--------------------------

(defmacro awhen (test &body body)
  `(let ((it ,test))
     (when it ,@body)))

9) not
10) and
11) or
12) xor

13) mapn - like map, but takes n lists as arguments (map is faster)
------------------------------------------------------------------

(defmacro mapn (f &rest xs)
  `((lambda (a xs)
      (let ((hs (map car xs)))
        (self (cons (eval `(apply ,f ,@xs)) a) (cdr xs))
        (reverse a))) () ,xs))

;; Warning: untested

14) setq

(defmacro setq (&rest rest)
  (lambda (vars values)
    `(mapn (lambda (var value)
             (set var value)) ,vars ,values)
    (map car vars)
    (map cadr vars)))

;; Warning: untested

last
nth
equal
pallindromep

member
list
sort
defun
