;; -*- mode: lisp -*-
;;
;; Note: Click in the title bar of the 'Listener' window to type in it
;;
;; WORK IN PROGRESS
;;
;; Problems? Email root@busfactor1.ca
;;

The Order of Symbols
--------------------

Lisp as a programming language is as Latin is to English or modern day
Italian.  It is the second oldest high level computer language still
in use, invented (or found) in the 1950's by John McCarthy and is the
most powerful and expressive programming language there is [citation
needed].  Lisp comes in many shapes and forms and Sigil is no
different.  It is a 'dialect' of Lisp, as Lisp is more of an idea than
a concrete thing, with all dialects looking similar, but behaving,
sometimes, very differently.  And like any dialect of a language, it
is malleable and modifiable, something which I will show you though
this document as we build our language from base principals (axioms).

The following is meant to be both an introduction and reference to
Sigil, the Lisp that is used by Eturia.  You will find an explanation
of syntax, followed by a brief explanation of Eturia, the Listener and
Window Manager, followed by the list of builtins, and then a set of
examples that can be followed along and typed into the Eturia
Listener, which can be found at:

    http://busfactor1.ca/bin/eturia/client/dev.html

This paper is intended to follow the ideas of Guy Steele in his
talk/paper 'Growing a language':

    https://www.cs.virginia.edu/~evans/cs655/readings/steele.pdf
    https://www.youtube.com/watch?v=_ahvzDzKdB0

All terms in the following text are (hopefully) defined before use.

Intended Audience
-----------------

This work is intended for both beginners and professionals alike.  For
beginners, if they work through the exercies, should gain an
understanding for all of the code and exercises given, with a little
thought.  Professionals may benefit in the same way, finding the
material refreshing over the typical code chaos one might see at work,
while learning something new and, hopefully, interesting: programming
language design and implementation.

The main desire of the reader should be to learn to program.  This is
not a traditional programming course in any way and will teach you
little on how to get a job as a programmer.  But knowing what this
course will teach you will benefit you for as long as you act as a
programmer during your life [citation needed].

Eturia
------

Eturia is a (similated) computer for Computer Science Education.  It
is designed to be simple and limited, perfect for teaching and
learning with few distractions.  Although probably unfamiliar at
first, it's spartan interface can be quickly learned by any newcomer
with its few and simple commands. Finally, it runs in a Web browser,
so it is accessable from any location with an internet connection.

The current version of Eturia can always be found at:

    http://busfactor1.ca/bin/eturia

along with videos and other information about the project.

The Listener
------------

There is no copy/pasting in Eturia.  To enter the code, it must be
typed manually into the 'Listener'.  This way the code will go through
your fingers and your brain, giving you a better chance of learning
the concepts as you go along and build your own language in Sigil.

This 'Listener' is like Like VI, but a bit different:

i - insert mode, allows you to type overwrite text in the buffer
? - command mode, allows you to execute the following commands
    and break out of insert mode
hjkl - move the cursor left, down, up, or right (h,j,k,l)
e - evaluate lisp code
z - clear the screen
np - previous/next in history (experimental)

To type characters use 'insert' (overwrite) mode by pressing 'i'. You
can tell when you are in 'insert' mode by the GREEN border around the
console.  To 'escape' out of insert mode, press '?'.

REMEMBER TO CLICK IN THE WINDOW TITLE BEFORE TRYING TO TYPE IN THE
LISTENER.

Window Manager
--------------

    - click in title bar to focus window
    - middle click in title bar to remove window

======
Syntax
======

The following is the syntax of Sigil:

Numbers - a string of digits
----------------------------

Example:

    1 is a number
    100 is a number
    3.141516 is a number
    -3 is a number


Symbol - a string of characters not containing '(', or ')'.
-----------------------------------------------------------

Example:

    x is a symbol
    abc is a symbol
    x123 is a symbol
    123x is a symbol
    a-longer-symbol is a symbol
    |a symbol with spaces| is a symbol


Comments - a string of characters up to a newline that is ignored
------------------------------------------------------------------

Example:

    ; this is a comment


List - build lists
------------------

Example:

    () ; the empty list
    (1) ; a 'proper' list containing the digit 1
    (1 2 3) ; is a 'proper' list of the digits 1 2 3
    (1 2 3 . ()) ; is a 'proper' list of the digits 1 2 3
    (1 . 2) ; is an 'improper' list of the digits 1 and 2

A proper list has () as its last element it is just not normally
shown.  An improper list does not.

Quoting - stops evaluation
--------------------------

Example: 
`1 => 1
x => ; Error, undefined symbol
`x => x
`(1 2 3) => (1 2 3)


Comma - evaulate inside of a quote
----------------------------------

Example:

    (set `x 1) => 1
    x => 1
    `(x 2 3) => (x 2 3)
    `(,x 2 3) => (1 2 3)


Commaat - evaluate a list inside of a quote, and splice it
----------------------------------------------------------

Example:

    (set `x `(a b c))
    x => (a b c)
    `(x 1 2 3) => (x 1 2 3)
    `(,x 1 2 3) => ((a b c) 1 2 3)
    `(,@x 1 2 3) => (a b c 1 2 3)


NOTE: SYMBOLS AND NUMBERS ARE ALSO KNOWN AS ATOMS.

 -------------------------------------------------
| Booleans - () is false, everything else is true |
 -------------------------------------------------

As in most languages, Sigil has the idea of booleans, true and false.
In this case, the empty list, () is 'false' and everything else is
'true'.  A special symbol 't' is defined to represent truth when
needed, but is not required to be used.

Functions that are meant to return either a true or false value are
known as 'predicates'.

Builtins
========

The following are the builtin commands for Sigil:

1) atom - a predicate to test if its argument is an atom (string, number, or ())
---------------------------------------------------------------------------------

Example:

    (atom t) => t
    (atom ()) => t
    (atom `x) => t
    (atom `(1 2 3)) => ()

2) eq - a predicate to test if 2 atoms are equal
------------------------------------------------
Example:

    (eq t t) => t
    (eq () ()) => t
    (eq t ()) => ()
    (eq `x `x) => t
    (eq `x `y) => ()
    (eq 1 1) => t
    (eq 1 2) => ()
    (eq `(1 2 3) `(1 2 3)) => () ; notice!

3) cons - create a new list cell
--------------------------------

Example:

    (cons 1 ()) => (1)
    (cons `x ()) => (x)
    (cons 1 2) => (1 . 2) ; notice! an improper list
    (cons (1 (cons 2 ()))) => (1 2) ; a proper list

4) car - return the first element of a list
-------------------------------------------

Example:

    (car `(1 2 3)) => 1
    (car `((1 2 3) 2 3)) => (1 2 3)
    (car ()) => ()
    (car `x) => ; Error
    (car 1) => ; Error

5) cdr - return everything but the first element of a list
----------------------------------------------------------

Example:

    (cdr `(1 2 3)) => (2 3)
    (cdr `((1 2 3) 2 3)) => (2 3)
    (cdr ()) => ()
    (cdr `x) => ; Error
    (cdr 1) => ; Error

6) cond - conditional statement, execute tests until one returns not (),
          and then execute the following statement
------------------------------------------------------------------------

Example:

    (cond (t 1)) => 1
    (cond (() 1)) => ()
    (cond ((t 1) (t 2))) => 1
    (cond ((() 1) (t 2))) => 2
    (cond ((() 1) (() 2) (t 3))) => 3
    (cond ((() 1) (t 2) (t 3))) => 2
    (set `x ())
    (set `y t)
    (cond
      (x `shouldnt-get-here)
      (y `should-get-here)
      (t `wont-get-here)) => should-get-here

7) qquote - prevent evaluation of the argument, allowing for unquote
            and unquote splicing, normally abbreviated with `
--------------------------------------------------------------------

Example:

    `(1 2 3) => (1 2 3)
    (set `x 1) => 1
    `(,x 2 3) => (1 2 3) ; unquote with ,
    `(,@x 2 3) => (1 2 3) ; Error
    (set `x `(1 2 3)) => (1 2 3)
    `(,x 2 3) => ((1 2 3) 2 3) ; unquote with ,
    `(,@x 2 3) => (1 2 3 2 3) ; unquote splice a list with ,@

8) set - assign a symbol a value (variables)
--------------------------------------------

Example:

    (set `x 1) => 1
    x => 1
    (set `x 2) => 2
    x => 2
    (set `x `(1 2 3)) => (1 2 3)
    x => (1 2 3)
    (set `x 1 `y 2 `z 3) => 3

9) lambda - create an anonymous function
----------------------------------------
Example:

    (lambda (x) x) => (lambda (x) x)
    ((lambda (x) x) 1) => 1 ; call the function immediately
    ((lambda (x) (+ x x)) 2) => 4
    (set `double (lambda (x) (+ x x))) ; declare function
    (double 2) => 4 ; call declared function

10) self - the current function that is executing, used for recursion
---------------------------------------------------------------------

Example:

    ((lambda (l)
       (cond
         ((cdr l) (car l))
         (t (self (cdr l))))) `(1 2 3)) => (3) ; return the last element
                                               ; of the list, recursively

11) apply - call a function with a list of arguments
----------------------------------------------------

Example:

    (apply (lambda (x) (+ x x)) `(1)) => 2
    (apply (lambda (x y z) (+ x y z)) `(1 2 3)) => 6
    (apply double 2) => 4 ; using previously defined function in 9)

12) values - return multiple values from a function
---------------------------------------------------

Example:

    (values 1) => 1
    (values 1 2) => 1
    2
    ((lambda (x) (values x)) 1) => 1
    ((lambda (x y) (values x y)) 1 2) => 1
    2

13) bind - bind multiple values to symbols
------------------------------------------

Example:

    (set `multiple-values (lambda (x y) (values x y))) => ...
    (bind (a b) (multiple-values 1 2) (cons a b)) => (1 . 2)

14) defmacro - define a macro
-----------------------------

Just watch the show, that's what it's about, mostly:

    https://www.livecoding.tv/burtonsamograd/videos

WRITEME

15) + - addition, sum
---------------------

Example:

    (+ 1 2) => 3
    (+ 1 2 3) => 6

16) - - subtraction, difference
-------------------------------

    (- 1 2) => -1
    (- 1 2 3) => -4

17) * - multipley, product
--------------------------

    (* 1 2) => 2
    (* 1 2 3) => 6

18) / - divide, quotient
------------------------

Example: 

    (/ 1 2) => .5
    (/ 1 2 3) => 0.1666....

19) % - remainder, mod
----------------------

Example:

    (% 5 2) => 1

20) rm - remove a symbol from the environment

Example:

    (set `x 1) => 1 ; define a symbol in the environment
    x => 1
    (rm `x) => 1 ; returns the old value of x
    x => ; Error, undefined symbol

21) rmf - remove a macro from the function environment

Example:

    (defmacro double (x) `(+ x x)) => (macro (x) `(+ ,x ,x))
    (double 2) => 4
    (rmf `double) => (macro (x) `(+ ,x ,x))
    (rm `double) => (lambda (x) (+ x x))
    (double 2) => ; Error, undefined function

22) env - return the current environment

Example:

     (env) => ((t . t) ...)

23) fenv - return the current function environment

Example:

    (fenv) => ((set . builtin) (cons . builtin) ...)

24) save - save the current environment and function environment to
           local storage using argument as the name of the core
--------------------------------------------------------------------

(save) => ; default /core is saved
(save /backup) => ; saved to /backup in local storage

25) load - load a core into the current environment

THIS FEATURE IS CURRENTLY NOT IMPLMENTED.

26) me - macro expand
---------------------

Example: (me (cadr `(1 2 3))) => (car (cdr `(1 2 3)))

============
|The Basics|
============

The following exercies build upon the primitives defined above and are
meant to be typed into the Eturia 'Listener' console.  The 'Examples'
can be used as test cases to ensure the correctness of your inputs.

0) first, second, third, rest - shortcuts
-----------------------------------------

(defmacro first (x)
  `(car ,x))

(defmacro second (x)
  `(car (cdr ,x)))

(defmacro third (x)
  `(car (cdr (cdr ,x))))

(defmacro rest (x)
  `(cdr ,x))

Examples:

    (first `(1 2 3)) => 1
    (second `(1 2 3)) => 2
    (third `(1 2 3)) => 3
    (rest `(1 2 3)) => (2 3)

1) if - tradional conditional
-----------------------------

(defmacro if (test true false)
  (cond
    (,test ,true)
    (t ,false)))
    
Example: 

    (if (eq t t) 1 2) => 1
    (if (eq t ()) 1 2) => 2

2) when - single branch conditional
-----------------------------------

(defmacro when (test &body body)
  (cond
    (,test ,@body)))

Example: 
    (when (eq t t) 1) => 1
    (when (eq t ()) 1) => ()

3) unless - negative single branch conditional
----------------------------------------------

(defmacro unless (test &body body)
  (cond ,test ,@body))

Example:
    (unless (eq t t) 1) => ()
    (unless (eq t ()) 1) => 1

4) reverse - reverse a list
---------------------------

(defmacro reverse (l)
  `((lambda (l a)
      (if l
          (self (cdr l) (cons (car l) a))
          a))))

Example: 

    (reverse `(1 2 3)) => (3 2 1)

5) map - build a list by running the function f ovar the entries in
         list l
-------------------------------------------------------------------

(defmacro map (f l)
  `((lambda (l a)
      (if l
          (self (cdr l) (cons (,f (car l))))
          (reverse a))) ,l ()))

Example:

    (map (lambda (x) (+ x x)) `(1 2 3)) => (2 4 6)

5.5) caar, cadr, cdar and cddr - shortcuts
------------------------------------------

(defmacro caar (x)
  `(car (car ,x)))

(defmacro cadr (x)
  `(car (cdr ,x)))

(defmacro cdar (x)
  `(cdr (car ,x)))

(defmacro cddr (x)
  `(cdr (cdr ,x)))

6) let - declare local variables
--------------------------------

(defmacro let (args &body body)
  (lambda (vars values)
    `((lambda ,vars ,@body) ,@args)
    (map car args)
    (map cadr args))) ; FIXME: this should work, if not, try the below version

(defmacro let (args &body body)
  (lambda (vars values)
    `((lambda ,vars ,@body) ,@args)
    (map car args)
    (map (lambda (x) (car (cdr x)) args))))

Examples:

    (let ((x 1) (y 2)) (+ x y)) => 3

7) aif - anamorphic if
----------------------

(defmacro aif (test true false)
  `(let ((it ,test))
     (if it ,true ,false)))

8) awhen - anamorphic when
--------------------------

(defmacro awhen (test &body body)
  `(let ((it ,test))
     (when it ,@body)))

9) not - logical compliment
---------------------------

(defmacro not (x)
  `((lambda (x)
      (cond
        ((null x) t)
        (t ())))))

Examples:

    (not ()) => t
    (not t) => ()
    (not 1) => ()

10) and - logical and
---------------------

(defmacro and (&rest args)
  `((lambda (args)
      (if args
          (if (eval (car args))
              (self (cdr args))
              ())
          t)) `,args))

Examples:

    (and () ()) => ()
    (and () t) => ()
    (and t ()) => ()
    (and t t) => t
    (and 1 1) => t

11) or - logicial or
---------------------

(defmacro or (&rest args)
  `((lambda (args)
      (if args
          (if (eval (car args))
              t
              (self (cdr args)))
          ())) `,args))

Examples:

    (or () ()) => ()
    (or () t) => t
    (or t ()) => t
    (or t t) => t
    (or 1 1) => t

12) xor - logical exclusive or

(defmacro xor (x y)
  `(let ((xe ,x)
         (ye ,y))
     (and
      (or xe ye)
      (not (and xe ye)))))

Examples:

    (xor () ()) => ()
    (xor t ()) => t
    (xor () t) => t
    (xor t t) => ()

;; WARNING: THE FOLLOWING CODE IS ALL UNTESTED

13) mapn - like map, but takes n lists as arguments (map is faster)
------------------------------------------------------------------

(defmacro mapn (f &rest xs)
  `((lambda (a xs)
      (let ((hs (map car xs)))
        (self (cons (eval `(apply ,f ,@xs)) a) (cdr xs))
        (reverse a))) () ,xs))

Examples:

    (mapn (lambda (x y) (+ x y)) `(1 2 3) `(1 2 3)) => (2 4 6)
    (mapn (lambda (x y) (+ x y)) `(x y z) `(a b c) `(1 2 3)) => (xa1 yb2 zc3)

14) setq

(defmacro setq (&rest rest)
  (lambda (vars values)
    `(mapn (lambda (var value)
             (set var value)) ,vars ,values)
    (map car vars)
    (map cadr vars)))

Examples:

    (setq x 1) => 1
    x => 1
    (setq x 2 y 3) => 3
    x => 2
    y => 3

15) last - return the last element of a list
--------------------------------------------

(defmacro last (l)
  `((lambda (l)
      (if (cdr l)
          (self (cdr l))
          (car l)))) ,l))

Examples:

(last `(1 2 3)) => 3

16) nth - return the nth element of a list
------------------------------------------

(defmacro nth (n l)
  `((lambda (n l)
      (if (eq n 0)
          l
          (self (- n 1) (cdr l))))) ,n ,l)

Examples:

    (nth 0 `(1 2 3)) => 1
    (nth 1 `(1 2 3)) => 2
    (nth 2 `(1 2 3)) => 3

17) equal - compare if two things are equal, including lists
------------------------------------------------------------

(defmacro equal (x y)
  `((lambda (x y)
      (cond
        ((and (atom x) (atom y)) (eq x y))
        ((and (null x) (null y)) t)
        (t
         (self (cdr x) (cdr y))))) ,x ,y))

18) pallindromep - see if a list is the same forwards and backwards
-------------------------------------------------------------------

(defmacro pallindromep (l)
  `(equal l (reverse l)))

Examples:

    (pallindromep `(1 2 3)) => ()
    (pallindromep `(1 2 3 2 1)) => t

19) ls - list the current environment, briefly

(defmacro ls ()
  `(map car (env)))

Examples:

    (ls) => (t ...)

20) lsf - list the current function environment, briefly

(defmacro ls ()
  `(map car (fenv)))

Examples:

    (lsf) => (atom eval ...)

21) list - create a proper list of all arguments

(defmacro list (&rest rest)
  `(lambda (rest)
     rest) ,@rest)

Example:

    (list `a `b `c) => (a b c)
    (list 1 2 3) => (1 2 3)

22) member - see if something is in a list

(defmacro member (x l &rest test)
  `(let ((t (if ,test ,test eq)))
     (lambda (x l)
       (if l
           (if (t x (car l))
               l
               (self x (cdr l)))
           ())) ,x ,l))

Example:

    (member 1 `(1 2 3)) => (1 2 3)
    (member 3 `(1 2 3)) => (3)
    (member 4 `(1 2 3)) => ()
    (member `(1 2 3) `(a b c (1 2 3))) => ()
    (member `(1 2 3) `(a b c (1 2 3)) equal) => ((1 2 3))  


23) filter - remove elements from a list based on a predicate

(defun filter (f l)
  `((lambda (l a)
      (if l
          (if (,f (car l))
              (self (cdr l) (cons (car l) a))
              (self (cdr l) a))
          (reverse a))) ,l))

Examples:

    (filter (lambda (x) (eq x 1)) `(1 2 3)) => (2 3)
    (filter (lambda (x) (or (eq x 1) (eq x 3)) `(1 2 3)) => (2)

;; TO BE CONTINUED

flatten
assoc
sort
defun(?)

==========
|THE MIDS|
==========

==============================================
Mathematical Exercises 1 - Probablistic Primes
==============================================

==============================
Exercises 1 - Phrase Generator
==============================

=================================
Exercises 2 - S-Expression Editor
=================================

==================
Exercises 3 - Life
==================

====================================
Mathmatical Exercises 2 - Ray Tracer
====================================

==========================================
Exercises 4 - GPS (General Problem Solver)
==========================================

==============
|THE ADVANCED|
==============

=========================================
Exercises 5 - Boolean Propagator Networks
=========================================

============================================================
Mathematical Exercises 3 - A Calculus Differentiation Engine
============================================================

====================
Exercises 6 - Prolog
====================

===============================
Exercises 7 - A Prolog Compiler
===============================

===============================================
Mathmatical Exercises 4 - Multi-Core Ray Tracer
===============================================

========
|DREAMS|
========

===================================
Exercise 8 - A (Simulated) RISC CPU
===================================

====================================
Exercises 9 - A (Simulated) Lisp CPU 
====================================

================================================
Exercises 10 - A (Multi-Core Simulated) Lisp CPU 
================================================

--
This material is the result of many years of study and research, of
both myself and others.  I have chosen to write it down both for
myself and for others to benefit from it's knowledge.  It's opinions
are all mine, built apon those I have admired in the past, knowingly
or unknowningly.  I hope you find the material as useful and
entertaining as I have writing it down and preparing it.

Burton Samograd <root@busfactor1.ca>
Copyright - 2016

Yes, copyright.  If you wish to reproduce any of this work, please ask
my permission first.  Linking is fine.  That is all.
